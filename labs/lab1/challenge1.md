### 扩展练习 Challenge 1

[扩展练习1文档](https://chyyuu.gitbooks.io/ucore_os_docs/content/lab1/lab1_2_1_7_ex7.html)

* 扩展proj4,增加syscall功能，即增加一用户态函数，当内核初始完毕后，可从内核态返回到用户态的函数，而用户态的函数又通过系统调用得到内核态的服务

#### 相关文件

* [init.c](/ucore/kern/init/init_c_lab1.md)
* [trap.c](/ucore/kern/trap/trap_c_lab1.md)

### 扩展proj4，增加syscall功能

#### 背景知识

1. 什么是syscall？

   syscall即系统调用(System Call)。

   在计算中，系统调用（通常缩写为syscall）是一种编程方式，计算机程序通过该方法从执行其的操作系统内核请求服务。这可能包括与硬件相关的服务（例如，访问硬盘驱动器），创建和执行新进程以及与诸如进程调度之类的集成内核服务进行通信。系统调用提供了进程与操作系统之间的基本接口。

2. 如何实现系统调用(syscall)？

   实施系统调用需要将控制权从用户空间转移到内核空间，这涉及某种特定于体系结构的功能。一种典型的实现方法是使用软件中断或陷阱。中断将控制转移到操作系统内核，因此软件仅需要使用所需的系统调用号设置一些寄存器，然后执行软件中断即可。

3. 什么是软件中断？

   中断可大体分为硬件中断和软件中断。具体分类及介绍如下：

   * 硬件中断（Hardware Interrupt）：
     * 可屏蔽中断（maskable interrupt）。硬件中断的一类，可通过在中断屏蔽寄存器中设定位掩码来关闭。
     * 非可屏蔽中断（non-maskable interrupt，NMI）。硬件中断的一类，无法通过在中断屏蔽寄存器中设定位掩码来关闭。典型例子是时钟中断（一个硬件时钟以恒定频率—如50Hz—发出的中断）。
     * 处理器间中断（interprocessor interrupt）。一种特殊的硬件中断。由处理器发出，被其它处理器接收。仅见于多处理器系统，以便于处理器间通信或同步。
     * 伪中断（spurious interrupt）。一类不希望被产生的硬件中断。发生的原因有很多种，如中断线路上电气信号异常，或是中断请求设备本身有问题。
   * 软件中断（Software Interrupt）：
     * 软件中断。是一条CPU指令，用以自陷一个中断。由于软中断指令通常要运行一个切换CPU至内核态（Kernel Mode/Ring 0）的子例程，它常被用作实现系统调用（System call）。

   处理器通常含有一个内部中断屏蔽位，并允许通过软件来设定。一旦被设定，所有外部中断都将被系统忽略。这个屏蔽位的访问速度显然快于中断控制器上的中断屏蔽寄存器，因此可提供更快速地中断屏蔽控制。

   * 如果一个中断使得机器处于一种确定状态，则称为精确中断（precise interrupt）。精确中断须保证：
     * 程序计数器的值被保存在已知位置。
     * 程序计数器所指向的指令之前的所有指令已被执行完毕。
     * 程序计数器所指向的指令之后的所有指令不可被执行。如果中断信号到来后而转入处理前发生了任何针对寄存器／内存的更改，都必须予以还原。
     * 程序计数器所指向的指令地执行状态已知。

   倘无法满足以上条件，此中断被称作非精确中断（imprecise interrupt）。

4. 如何执行软件中断？

   在软件内调用汇编指令`int`即可引发软件中断

#### 问题分析

1. 如何从内核态切换到用户态？

   如何从内核态切换到用户态？对于这个问题，我们将它分成两个部分：引发中断和中断处理。具体操作参考问题2和问题3。

2. 如何引发从内核态切换到用户态的软中断？

   首先，在`trap.h`中已经定义了内核态切换到用户态的中断号`T_SWITCH_TOU`，即`trap_switch_to_user`的缩写。有了这个之后，我们可以直接引发该中断：

   ```c
   //	File:	init.c

   static void
   lab1_switch_to_user(void) {
	   asm volatile (
	       "int %0 \n"
	       : 
	       : "i"(T_SWITCH_TOU)
	   );
   }
   ```

   但直接引发中断有一个问题。我们查阅Intel的文档可以知道，引发中断时CPU会将寄存器内的一些状态保存到栈中，但有一个例外，就是SS与ESP寄存器。

   在内核态引发的中断会将SS与ESP寄存器的值保存到TSS(Task State Segment)中，而用户态的SS与ESP寄存器的值则会正常保存到栈中，那么问题来了：该怎样做才能使得特权级可以正常切换呢？

   答案就是：引发中断前，在栈中预留给SS和ESP的位置，然后在中断的处理过程中为其赋正确的值，中断处理结束后即可正常进入用户态。

   所以，在`int`语句之前，我们要对`esp`寄存器进行`sub`操作，使栈扩大一部分，为SS和ESP寄存器的值预留出空间。

   这里需要说明的一点是，SS和ESP所指向的内存中的栈，其中栈底在上方，栈顶在下方，所以为了使栈扩大，我们需要对ESP寄存器进行的操作是使其所指地址减小而不是增大。

   那么，我们需要移动的尺寸是多少呢？众所周知，ESP是32bit的，SS的可用部分是16bit的，但是作为一个32位处理器的寄存器，SS的实际尺寸是32bit，其中还有16bit存放这一些标志位。所以需要让栈顶指针移动的长度为64bit，即8字节。

   这样分析完成之后，我们将代码改成了如下的样子：

   ```c
   //	File:	init.c

   static void
   lab1_switch_to_user(void) {
	   asm volatile (
           "sub $0x8, %%esp \n"
	       "int %0 \n"
	       : 
	       : "i"(T_SWITCH_TOU)
	   );
   }
   ```

   还没完，由于编译器没有识别到我们在函数内对ESP做了变化，因此我们还要处理一些后事。

   通常情况下，在C语言中的一个函数，编译时*GCC*会在函数头部和尾部添加一些汇编指令来保证函数的正常运行。比如头部会添加`push %ebp`和`mov %esp, %ebp`，该指令的作用是把之前的栈帧压到栈中，再调整栈帧，相当于设置了一个栈底，不让函数内的操作越过自身的栈内存从而访问到不该访问的空间。

   同理，函数尾部也会被添加`mov %ebp, %esp`和`pop %ebp`来对栈进行还原。这两个指令也可以简写成一条指令`leave`。

   这里需要说明的是，头部的两条指令是必须添加的，因为要保护内存，但是当编译器没有检测到函数内有对栈的正常操作，即函数内栈没有变化，为节省开销，尾部的`mov %ebp, %esp`就可以不填加。

   那么问题来了，其实我们的汇编指令是有对栈的操作的，而且还不少，但是内联汇编并不属于对栈的正常操作，因此没有被*GCC*检测到，所以为了让我们的操作系统正常工作，必须把被省略的`mov %ebp, %esp`给补上。

   解决方案有两种，第一种：手动添加该指令

   ```asm
   static void
   lab1_switch_to_user(void) {
       //LAB1 CHALLENGE 1 : TODO
	   asm volatile (
	       "sub $0x8, %%esp \n"
	       "int %0 \n"
	       "movl %%ebp, %%esp"
	       : 
	       : "i"(T_SWITCH_TOU)
	   );
   }
   ```

   这样就将问题解决了。但我们还有第二种方法，就是让编译器意识到在这个语句里ESP寄存器被改变了，让编译器自己把这条语句给加上：

   ```asm
   static void
   lab1_switch_to_user(void) {
       //LAB1 CHALLENGE 1 : TODO
	   asm volatile (
	       "sub $0x8, %%esp \n"
	       "int %0 \n"
	       : 
	       : "i"(T_SWITCH_TOU)
		   : "%esp"
	   );
   }
   ```

   内联汇编的语法中，`asm`函数的参数是需要执行的汇编指令，后面还有三个可选的参数，用冒号分隔，分别是从汇编指令的输出的变量、输入到汇编指令的变量、汇编指令中破坏（编辑）过的寄存器。

   我们在此声明，ESP寄存器被我们编辑过，编译的时候*GCC*就会把最后需要的`mov %ebp, %esp`给补上了。

3. 如何处理中断使特权级切换到用户态？

   更新中

4. 如何引发从用户态切换到内核态的软中断？

   更新中

5. 如何处理中断使特权级切换到内核态？

   更新中

#### 参考文献

* [System Call - Wikipedia](https://en.wikipedia.org/wiki/System_call)
* [中断 - 维基百科](https://zh.wikipedia.org/wiki/%E4%B8%AD%E6%96%B7)
* [x86内存分段 - 维基百科](https://zh.wikipedia.org/wiki/X86%E8%A8%98%E6%86%B6%E9%AB%94%E5%8D%80%E6%AE%B5)
* [Lab1 Challenge1中关于 mov %ebp, %esp 意义的讨论](https://piazza.com/class/i5j09fnsl7k5x0?cid=1468)
* [Intel® 64 and IA-32 ArchitecturesSoftware Developer’s Manual](https://software.intel.com/sites/default/files/managed/39/c5/325462-sdm-vol-1-2abcd-3abcd.pdf)
  * Chap. 6.4.5, Vol. 1，介绍特权级相关内容
    * 注：旧版本文档内位于Chap. 6.3.5
  * Chap. 7, Vol. 3，介绍TSS相关内容

